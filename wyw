#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>



// 跨平台宏定义（区分Windows和Linux/macOS）
#ifdef _WIN32
#define PAUSE "pause"
#define CLEAR "cls"
#else
#define PAUSE "read -p '按任意键继续...' var"
#define CLEAR "clear"
#endif

// 宏定义常量
#define MAX_NAME 50      // 物品名称最大长度
#define MAX_TYPE 20      // 物品类型最大长度
#define MAX_PLACE 50     // 拾获地点最大长度
#define MAX_CONTACT 30   // 联系方式最大长度
#define MAX_FEATURE 100  // 物品特征最大长度
#define FILE_PATH "lost_items.dat"  // 数据存储文件
#define INPUT_BUFFER 100 // 输入缓冲区大小

// 失物信息结构体
typedef struct LostItem {
    int id;                  // 唯一标识ID
    char name[MAX_NAME];     // 物品名称
    char type[MAX_TYPE];     // 物品类型（证件/电子/生活用品等）
    char place[MAX_PLACE];   // 拾获地点
    char time[20];           // 拾获时间（YYYY-MM-DD HH:MM）
    char finder[MAX_CONTACT];// 拾获人联系方式
    char feature[MAX_FEATURE];// 物品特征描述
    int is_claimed;          // 认领状态（0-未认领，1-已认领）
    struct LostItem* next;   // 链表指针
} LostItem;

// 函数声明
LostItem* create_item(int id);                  // 创建新失物节点
void add_item(LostItem** head, LostItem* item);  // 添加节点到链表
void delete_item(LostItem** head, int id);      // 从链表删除节点
LostItem* find_item(LostItem* head, int id);    // 按ID查找节点
int get_max_id(LostItem* head);                 // 获取当前最大ID（用于自增）
void save_to_file(LostItem* head);              // 保存链表到文件
LostItem* load_from_file();                     // 从文件加载链表
void free_list(LostItem* head);                 // 释放链表内存
int read_int_input(const char* prompt);         // 安全读取整数输入
void read_str_input(const char* prompt, char* buf, int max_len); // 安全读取字符串输入

// 功能函数声明
void register_item(LostItem** head);            // 登记失物
void query_by_type(LostItem* head);             // 按类型查询
void query_by_place(LostItem* head);            // 按地点查询
void mark_claimed(LostItem* head);              // 标记物品为已认领
void show_all(LostItem* head);                  // 显示所有失物
void delete_item_menu(LostItem** head);         // 删除失物菜单
void show_menu();                               // 显示菜单

// 主函数
int main() {
    LostItem* head = load_from_file();  // 启动时加载数据
    int choice;

    do {
        show_menu();
        choice = read_int_input("请输入操作编号: ");

        switch (choice) {
        case 1:
            register_item(&head);
            break;
        case 2:
            query_by_type(head);
            break;
        case 3:
            query_by_place(head);
            break;
        case 4:
            mark_claimed(head);
            break;
        case 5:
            show_all(head);
            break;
        case 6:
            delete_item_menu(&head);
            break;
        case 0:
            save_to_file(head);  // 退出前保存数据
            free_list(head);     // 释放内存
            printf("感谢使用，再见！\n");
            break;
        default:
            printf("输入错误，请重新选择！\n");
        }
        system(PAUSE);  // 跨平台暂停
        system(CLEAR);  // 跨平台清屏
    } while (choice != 0);

    return 0;
}


// 创建新失物节点
// 创建新失物节点（修改时间获取逻辑）
LostItem* create_item(int id) {
    LostItem* item = (LostItem*)malloc(sizeof(LostItem));
    if (!item) {
        printf("内存分配失败！\n");
        exit(1);
    }
    item->id = id;
    item->is_claimed = 0;  // 初始为未认领
    item->next = NULL;

    // 用 localtime_s 替代 localtime（安全版本）
    time_t now = time(NULL);
    struct tm t;  // 显式定义结构体，而非使用全局指针
    localtime_s(&t, &now);  // 第一个参数：存储时间的结构体地址；第二个参数：time_t 变量地址
    sprintf(item->time, "%04d-%02d-%02d %02d:%02d",
        t.tm_year + 1900, t.tm_mon + 1, t.tm_mday,
        t.tm_hour, t.tm_min);

    return item;
}

// 添加节点到链表（尾插法）
void add_item(LostItem** head, LostItem* item) {
    if (*head == NULL) {
        *head = item;
    }
    else {
        LostItem* p = *head;
        while (p->next != NULL) {
            p = p->next;
        }
        p->next = item;
    }
}

// 从链表删除节点
void delete_item(LostItem** head, int id) {
    if (*head == NULL) {
        printf("无失物信息可删除！\n");
        return;
    }

    LostItem* p = *head;
    LostItem* prev = NULL;

    // 查找目标节点
    while (p != NULL && p->id != id) {
        prev = p;
        p = p->next;
    }

    if (p == NULL) {
        printf("未找到ID为%d的失物！\n", id);
        return;
    }

    // 删除节点
    if (prev == NULL) {  // 头节点
        *head = p->next;
    }
    else {
        prev->next = p->next;
    }
    free(p);
    printf("ID为%d的失物信息已删除！\n", id);
}

// 按ID查找节点
LostItem* find_item(LostItem* head, int id) {
    LostItem* p = head;
    while (p != NULL) {
        if (p->id == id) {
            return p;
        }
        p = p->next;
    }
    return NULL;
}

// 获取当前最大ID
int get_max_id(LostItem* head) {
    int max_id = 0;
    LostItem* p = head;
    while (p != NULL) {
        if (p->id > max_id) {
            max_id = p->id;
        }
        p = p->next;
    }
    return max_id;
}

// 保存链表到文件（二进制存储）
void save_to_file(LostItem* head) {
    FILE* fp = fopen(FILE_PATH, "wb");
    if (!fp) {
        printf("文件打开失败，无法保存数据！\n");
        return;
    }

    LostItem* p = head;
    while (p != NULL) {
        // 写入时忽略next指针（避免存储无效地址）
        LostItem temp = *p;
        temp.next = NULL;
        fwrite(&temp, sizeof(LostItem), 1, fp);
        p = p->next;
    }

    fclose(fp);
    printf("数据已成功保存！\n");
}

// 从文件加载链表
LostItem* load_from_file() {
    FILE* fp = fopen(FILE_PATH, "rb");
    if (!fp) {
        printf("首次使用，未检测到历史数据！\n");
        return NULL;
    }

    LostItem* head = NULL;
    LostItem* item;
    while (1) {
        item = (LostItem*)malloc(sizeof(LostItem));
        if (!item) {
            printf("内存分配失败！\n");
            free_list(head);  // 释放已分配的内存
            fclose(fp);
            exit(1);
        }
        // 读取结构体，判断是否到文件末尾
        if (fread(item, sizeof(LostItem), 1, fp) != 1) {
            free(item);
            break;
        }
        item->next = NULL;  // 重置next指针
        add_item(&head, item);
    }

    fclose(fp);
    printf("历史数据加载成功！\n");
    return head;
}

// 释放链表内存
void free_list(LostItem* head) {
    LostItem* p = head;
    while (p != NULL) {
        LostItem* temp = p;
        p = p->next;
        free(temp);
    }
}

// 安全读取整数输入（处理无效输入）
int read_int_input(const char* prompt) {
    char input[INPUT_BUFFER];
    int value;
    while (1) {
        printf("%s", prompt);
        if (fgets(input, sizeof(input), stdin) == NULL) {
            printf("输入错误，请重新输入！\n");
            clearerr(stdin);  // 清除输入错误标志
            continue;
        }
        // 尝试转换为整数
        if (sscanf_s(input, "%d", &value,sizeof(value)) ) {
            // 检查是否有多余字符（仅允许数字和换行）
            if (input[strlen(input) - 1] != '\n') {
                printf("输入过长，请重新输入！\n");
                // 清空输入缓冲区
                while (getchar() != '\n');
                continue;
            }
            return value;
        }
        else {
            printf("请输入有效的整数！\n");
        }
    }
}

// 安全读取字符串输入（处理空输入和超长输入）
void read_str_input(const char* prompt, char* buf, int max_len) {
    while (1) {
        printf("%s", prompt);
        if (fgets(buf, max_len, stdin) == NULL) {
            printf("输入错误，请重新输入！\n");
            clearerr(stdin);
            continue;
        }
        // 去除换行符
        buf[strcspn(buf, "\n")] = '\0';
        // 检查空输入
        if (strlen(buf) == 0) {
            printf("输入不能为空，请重新输入！\n");
            continue;
        }
        // 检查是否有未读取的字符（输入超长）
        if (strlen(buf) == max_len - 1 && buf[max_len - 2] != '\n') {
            printf("输入过长（最多%d个字符），请重新输入！\n", max_len - 1);
            // 清空输入缓冲区
            while (getchar() != '\n');
            continue;
        }
        break;  // 输入有效
    }
}

// 登记失物
void register_item(LostItem** head) {
    int new_id = get_max_id(*head) + 1;
    LostItem* item = create_item(new_id);

    printf("===== 失物登记 =====\n");
    read_str_input("物品名称: ", item->name, MAX_NAME);
    read_str_input("物品类型（证件/电子/生活用品等）: ", item->type, MAX_TYPE);
    read_str_input("拾获地点: ", item->place, MAX_PLACE);
    read_str_input("物品特征描述: ", item->feature, MAX_FEATURE);
    read_str_input("拾获人联系方式: ", item->finder, MAX_CONTACT);

    add_item(head, item);
    printf("登记成功！物品ID: %d\n", new_id);
}

// 按类型查询
void query_by_type(LostItem* head) {
    if (head == NULL) {
        printf("暂无失物信息！\n");
        return;
    }

    char type[MAX_TYPE];
    read_str_input("请输入查询的物品类型: ", type, MAX_TYPE);

    printf("\n===== 类型为【%s】的失物 =====\n", type);
    int count = 0;
    LostItem* p = head;
    while (p != NULL) {
        if (strcmp(p->type, type) == 0 && p->is_claimed == 0) {
            printf("ID: %d\n", p->id);
            printf("名称: %s\n", p->name);
            printf("拾获地点: %s\n", p->place);
            printf("拾获时间: %s\n", p->time);
            printf("特征: %s\n", p->feature);
            printf("拾获人: %s\n", p->finder);
            printf("-------------------\n");
            count++;
        }
        p = p->next;
    }

    if (count == 0) {
        printf("未找到相关未认领的失物！\n");
    }
    else {
        printf("共找到%d条记录\n", count);
    }
}

// 按地点查询
void query_by_place(LostItem* head) {
    if (head == NULL) {
        printf("暂无失物信息！\n");
        return;
    }

    char place[MAX_PLACE];
    read_str_input("请输入查询的拾获地点: ", place, MAX_PLACE);

    printf("\n===== 在【%s】拾获的失物 =====\n", place);
    int count = 0;
    LostItem* p = head;
    while (p != NULL) {
        if (strcmp(p->place, place) == 0 && p->is_claimed == 0) {
            printf("ID: %d\n", p->id);
            printf("名称: %s\n", p->name);
            printf("类型: %s\n", p->type);
            printf("拾获时间: %s\n", p->time);
            printf("特征: %s\n", p->feature);
            printf("拾获人: %s\n", p->finder);
            printf("-------------------\n");
            count++;
        }
        p = p->next;
    }

    if (count == 0) {
        printf("未找到相关未认领的失物！\n");
    }
    else {
        printf("共找到%d条记录\n", count);
    }
}

// 标记物品为已认领
void mark_claimed(LostItem* head) {
    if (head == NULL) {
        printf("暂无失物信息！\n");
        return;
    }

    int id = read_int_input("请输入要标记为已认领的物品ID: ");
    LostItem* item = find_item(head, id);

    if (!item) {
        printf("未找到ID为%d的失物！\n", id);
        return;
    }

    if (item->is_claimed == 1) {
        printf("该物品已被认领！\n");
        return;
    }

    item->is_claimed = 1;
    printf("ID为%d的物品已标记为已认领！\n", id);
}

// 显示所有失物
void show_all(LostItem* head) {
    if (head == NULL) {
        printf("暂无失物信息！\n");
        return;
    }

    printf("===== 所有失物信息 =====\n");
    LostItem* p = head;
    while (p != NULL) {
        printf("ID: %d\n", p->id);
        printf("名称: %s\n", p->name);
        printf("类型: %s\n", p->type);
        printf("拾获地点: %s\n", p->place);
        printf("拾获时间: %s\n", p->time);
        printf("状态: %s\n", p->is_claimed ? "已认领" : "未认领");
        printf("-------------------\n");
        p = p->next;
    }
}

// 删除失物菜单（封装删除功能的交互）
void delete_item_menu(LostItem** head) {
    if (*head == NULL) {
        printf("暂无失物信息可删除！\n");
        return;
    }

    int id = read_int_input("请输入要删除的物品ID: ");
    delete_item(head, id);
}

// 显示菜单
void show_menu() {
    printf("===== 校园失物招领系统 =====\n");
    printf("1. 登记失物\n");
    printf("2. 按类型查询失物\n");
    printf("3. 按地点查询失物\n");
    printf("4. 标记物品为已认领\n");
    printf("5. 显示所有失物\n");
    printf("6. 删除失物\n");
    printf("0. 退出系统\n");
    printf("===========================\n");
}
